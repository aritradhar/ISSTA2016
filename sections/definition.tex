\section{Problem Definition}
\label{sec:definition}

The properties that we consider in this work are either typestate properties or
typestate-like properties that may involve multiple objects. The properties
can be modelled using a deterministic DFA $\mathcal{A}$
that can be represented by a tuple $(Q, \Sigma, q_0, \delta, F, err)$, $Q$ is the set of states,
$\Sigma$ is the set of symbols, $q_0 \in Q$ is the start state, $\delta : Q \times \Sigma \to Q$ is the state transition
function, $F \subset Q$ is the set of accept states, and $err$ is the designated error state. Typically, 
$F \bigcup err = Q$ and $F \bigcap err = \emptyset$.

Let $\phi$ be the property a given program is being monitored for, and let
$O$ be the set of objects associated with $\phi$.  An event $\eta$ in the program
under execution is represented by a pair $(\beta, \sigma)$,
where $\beta \in 2^O$ is a set of objects associated with the event and $\sigma \in \Sigma$.

We define a monitor $m \in M$ parameterized by a pair a pair $(\alpha, cur)$ where $\alpha \in 2^O$ and
$cur \in Q$ is the current state of the monitor. We define a mapping $\psi : 2^O \nrightarrow 2^M$ which after receiving an event
$\eta = (\beta, \sigma)$ returns a set of monitors $\theta$
corresponding to $\beta$ where $\beta \subseteq \alpha$. Note that there is a unique monitor associated
with $\alpha$, but there may be more than one monitors associated with $\beta$ when $\beta \subset \alpha$.
The current state of every monitor that belongs to
$\theta$ is updated according to the symbol associated with the event. More formally,
$\forall m \in \theta: m.cur \leftarrow \delta(m.cur, \sigma)$. When $m.cur = err$, an error is reported.

A traditional unoptimized approach would use $\psi$ for locating monitors, whereas our proposed approach
generates a mapping $\psi': 2^O \nrightarrow 2^M$ such that $\psi' \subset \psi$.
In other words, the approach ignores an event $\eta = (\beta, \sigma)$ if $\psi'(\beta)$ is undefined, even if
$\psi(\beta)$ would have been defined. In addition, it return $\theta' \subseteq \theta$ to limit the monitors
that need to be updated for an event.

The key challenge in this case would be not to compromise too much with the error reporting. With the reduced
number of monitors our approach still tries to detect all distinct errors. Let $P$ be the set of error reports
generated by an unoptimized monitoring system. Let $\Pi$ be the set of programming contexts under which
$P$ was generated. $\pi \in \Pi$ be the programming context under which the report $\rho \in P$ was generated.

\begin{theorem}
$\mid P\mid \ge \mid \Pi \mid$.
\end{theorem}

\begin{proof}
An error report is produced under exactly one programming context. However, a
programming context $\pi_1$ can generate more than one error reports $\rho_1, \ldots ,\rho_n$. This is because during the program
execution, if an erroneous state is reached under a programming context $\pi_1$, the same state might be reached every time
under the context $\pi_1$ and an error report $\pi_k$ where $1 \le k \le n$ will be generated. Hence, the number of programming
contexts under which an erroneous state can be reached cannot be greater than the number of error reports.
\end{proof}

We partition the set $P$ into blocks $b_1, \ldots , b_n$ as follows. \\
$\rho_i \in b_k$ and $\rho_j \in b_k$ where  $1 \le k \le n$
iff $\exists x$ such that $\rho_i$ and $\rho_j$ were created under context $\pi_k$.
In other words, all error reports that fall under one block are created under same
programming context and hence we treat them equivalent.

The error reporting goal of our approach is to generate at least and ideally, exactly one report
for every block. More formally, the approach strives to achieve a minimal $P' \subset P$
such that $\forall i : P' \bigcap b_i \ne \emptyset$ where $1 \le i \le n$ and $P$ is partitioned into
$b_1, \ldots, b_n$.

