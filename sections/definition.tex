\section{Problem Definition}
\label{sec:definition}

We consider typestate properties or typestate-like properties~\note{Need to 
agree on what term to use. typestate is used here for the first time.} involving 
multiple objects. These properties are modeled using deterministic DFA 
$\mathcal{A}$ represented by the tuple $(Q, \Sigma, q_0, \delta, F, err)$, where 
$Q$ is the set of states, $\Sigma$ is the set of symbols, $q_0 \in Q$ is the 
start state, $\delta : Q \times \Sigma \to Q$ is the state transition function, 
$F \subset Q$ is the set of accept states, and $err$ is the designated error 
state. Typically, $F \bigcup err = Q$ and $F \bigcap err = \emptyset$. 

Let $\phi$ be the program property to be monitored, and let $O$ be the set of 
objects associated with $\phi$.  An event $\eta$ in the program under execution 
is represented by a pair $(\beta, \sigma)$, where $\beta \in 2^O$ is a set of 
objects associated with the event and $\sigma \in \Sigma$.

We define a monitor $m \in M$ parameterized by a pair $(\alpha, cur)$, where 
$\alpha \in 2^O$ and $cur \in Q$ is the current state of the monitor. We define 
a mapping $\psi : 2^O \nrightarrow 2^M$ that after receiving an event $\eta = 
(\beta, \sigma)$ returns a set of monitors $\theta$ corresponding to $\beta$, 
where $\beta \subseteq \alpha$. Note that there is a unique monitor associated
with $\alpha$, but there may be more than one monitor associated with $\beta$ 
when $\beta \subset \alpha$. The current state of every monitor that belongs to
$\theta$ is updated according to the symbol associated with the event. Formally, 
$\forall m \in \theta: m.cur \leftarrow \delta(m.cur, \sigma)$. We report an 
error when $m.cur = err$. \note{Not clear what is $\alpha$, and whether $\beta 
\subset \alpha$ or $\beta \subseteq \alpha$.}

\myparagraph{Our approach} A traditional unoptimized approach would use $\psi$ 
for locating monitors, whereas our approach generates a mapping $\psi': 2^O 
\nrightarrow 2^M$ such that $\psi' \subset \psi$. In other words, the approach 
ignores an event $\eta = (\beta, \sigma)$ if $\psi'(\beta)$ is undefined, even 
if $\psi(\beta)$ was defined. In addition, it return $\theta' \subseteq \theta$ 
to limit the monitors that need to be updated for an event.

A key challenge is not to compromise with error reporting. Even with reduced 
number of monitors, our approach still tries to detect all distinct errors. Let 
$P$ be the set of error reports generated by an unoptimized monitoring system. 
Let $\Pi$ be the set of programming contexts under which $P$ was generated. Let 
$\pi \in \Pi$ be the programming context under which the report $\rho \in P$ was 
generated.

\begin{theorem}
$\mid P\mid \ge \mid \Pi \mid$.
\end{theorem}

\begin{proof}
An error report is produced under exactly one programming context. However, a 
programming context $\pi_1$ can generate more than one error reports $\rho_1, 
\ldots ,\rho_n$. This is because during the program execution, if an erroneous 
state is reached under a programming context $\pi_1$, then the same state might 
also be reached every time under the context $\pi_1$ and an error report 
$\rho_k$ will be generated, where $1 \le k \le n$. Hence, the number of 
programming contexts under which an erroneous state can be reached cannot be 
greater than the number of error reports.
\end{proof}

We partition the set $P$ into blocks $b_1, \ldots , b_n$ as follows --- $\rho_i 
\in b_k$ and $\rho_j \in b_k$ where  $1 \le k \le n$ iff $\exists x$ \note{what 
is x?} such that $\rho_i$ and $\rho_j$ were created under the context $\pi_k$. 
In other words, all error reports that fall under one block are created under 
same programming context and hence we treat them equivalent. A key aim of our 
approach is to generate at least one report for every block. \note{'at least' 
or 'exactly' -- not sure of the wording here, so removed 'exactly', which 
seemed more stringent.} Formally, the approach strives to achieve a minimal $P' 
\subset P$ such that $\forall i : P' \bigcap b_i \ne \emptyset$ where $1 \le i 
\le n$ and $P$ is partitioned into $b_1, \ldots, b_n$.

\ignore{
The properties that we consider in this work are either typestate properties or
typestate-like properties that may involve multiple objects. The properties
can be modelled using a deterministic DFA $\mathcal{A}$
that can be represented by a tuple $(Q, \Sigma, q_0, \delta, F, err)$, $Q$ is the set of states,
$\Sigma$ is the set of symbols, $q_0 \in Q$ is the start state, $\delta : Q \times \Sigma \to Q$ is the state transition
function, $F \subset Q$ is the set of accept states, and $err$ is the designated error state. Typically, 
$F \bigcup err = Q$ and $F \bigcap err = \emptyset$.

Let $\phi$ be the property a given program is being monitored for, and let
$O$ be the set of objects associated with $\phi$.  An event $\eta$ in the program
under execution is represented by a pair $(\beta, \sigma)$,
where $\beta \in 2^O$ is a set of objects associated with the event and $\sigma \in \Sigma$.

We define a monitor $m \in M$ parameterized by a pair a pair $(\alpha, cur)$ where $\alpha \in 2^O$ and
$cur \in Q$ is the current state of the monitor. We define a mapping $\psi : 2^O \nrightarrow 2^M$ which after receiving an event
$\eta = (\beta, \sigma)$ returns a set of monitors $\theta$
corresponding to $\beta$ where $\beta \subseteq \alpha$. Note that there is a unique monitor associated
with $\alpha$, but there may be more than one monitors associated with $\beta$ when $\beta \subset \alpha$.
The current state of every monitor that belongs to
$\theta$ is updated according to the symbol associated with the event. More formally,
$\forall m \in \theta: m.cur \leftarrow \delta(m.cur, \sigma)$. When $m.cur = err$, an error is reported.

A traditional unoptimized approach would use $\psi$ for locating monitors, whereas our proposed approach
generates a mapping $\psi': 2^O \nrightarrow 2^M$ such that $\psi' \subset \psi$.
In other words, the approach ignores an event $\eta = (\beta, \sigma)$ if $\psi'(\beta)$ is undefined, even if
$\psi(\beta)$ would have been defined. In addition, it return $\theta' \subseteq \theta$ to limit the monitors
that need to be updated for an event.

The key challenge in this case would be not to compromise too much with the error reporting. With the reduced
number of monitors our approach still tries to detect all distinct errors. Let $P$ be the set of error reports
generated by an unoptimized monitoring system. Let $\Pi$ be the set of programming contexts under which
$P$ was generated. $\pi \in \Pi$ be the programming context under which the report $\rho \in P$ was generated.

\begin{theorem}
$\mid P\mid \ge \mid \Pi \mid$.
\end{theorem}

\begin{proof}
An error report is produced under exactly one programming context. However, a
programming context $\pi_1$ can generate more than one error reports $\rho_1, \ldots ,\rho_n$. This is because during the program
execution, if an erroneous state is reached under a programming context $\pi_1$, the same state might be reached every time
under the context $\pi_1$ and an error report $\pi_k$ where $1 \le k \le n$ will be generated. Hence, the number of programming
contexts under which an erroneous state can be reached cannot be greater than the number of error reports.
\end{proof}

We partition the set $P$ into blocks $b_1, \ldots , b_n$ as follows. \\
$\rho_i \in b_k$ and $\rho_j \in b_k$ where  $1 \le k \le n$
iff $\exists x$ such that $\rho_i$ and $\rho_j$ were created under context $\pi_k$.
In other words, all error reports that fall under one block are created under same
programming context and hence we treat them equivalent.

The error reporting goal of our approach is to generate at least and ideally, exactly one report
for every block. More formally, the approach strives to achieve a minimal $P' \subset P$
such that $\forall i : P' \bigcap b_i \ne \emptyset$ where $1 \le i \le n$ and $P$ is partitioned into
$b_1, \ldots, b_n$.
}
