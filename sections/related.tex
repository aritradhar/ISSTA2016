\section{Related Work}

There is a substantial work performed on runtime monitoring to ensure that the 
running software is in consistent state. These checks are performed either by 
reading the events generated by the software and then applying some logic that 
models the predefined rules or properties. Alternatively, the checks are 
performed implicitly by the programs when some extra code is inserted inside the 
programs. In majority of these cases the system is assumed to have abundant 
resources in terms of memory and have no time constraints. These assumptions do 
not hold for resource-constrained systems such as real-time embedded systems 
which pose serious challenges to runtime monitoring. We briefly discuss here 
some of the notable related work in runtime monitoring in general and runtime 
monitoring for embedded systems in particular.

\textbf{\textit {Approaches for Real-Time Systems}} A lot of work in the past 
has focussed on reducing time overhead of runtime monitoring. However, real-time 
embedded systems demand time-predictable or deterministic runtime monitoring. 
The challenge is in scheduling the monitoring activities so that they do not 
interfere with the software operation and do not violate the software's 
nonfunctional properties. Some approaches depend on event sampling and optimized 
time-triggering \cite{ArafaKF13, NavabpourBF12, WuKBF13}. Other approaches 
include predictable monitoring that provide bounds on detection latency 
\cite{ZhuDG09, ZhuGD10}. These approaches are effective, however, they do not 
target general finite state properties that might be related to multiple 
objects. Moreover, many of these approaches are unsuitable for inline 
monitoring. Our approach, in contrast, tries to support inline monitoring of 
finite state monitoring.

\textbf{\textit {Sampling-based approach}} \ignore {In [7], the authors have 
presented a specialized runtime environment, Quality Virtual Machine (QVM), 
targeted towards defect detection and diagnosis in production systems. It tracks 
safety properties, Java assertions and heap properties for violations. A novel 
overhead manager that enforces a user specified overhead budget for quality 
checks is a unique feature of QVM.To reduce the analysis overhead, QVM performs 
property-guided sampling ensuring the sampling is not done randomly. Another 
feature supported by QVM is object-centric sampling which allows to sample at 
the object instance level. If an object is sampled at allocation time, a bit is 
set in object header to mark the object as tracked. QVM tracks the number of 
times a typestate property has been violated and if the number passes a 
specified threshold, it starts recording typestate history. Typestate history of 
an object, the abstraction of method call invocations performed during execution 
with the 
object as reciever, gives the information about the way the object was used in 
the program that violates the property. QVM is implemented on top of JVM, which 
is an advantage but at the same time it comes with cost of non-portability. QVM 
can effectively monitor large applications but supports single-object typestate 
properties. This work is by far close to our approach but the QVMs approach is 
unsound as it cannot detect violations for objects that are dropped. However, we 
have ensured the soundness or completeness of our approach even after sampling 
the objects to reduce the overhead.}
Researchers have presented approaches that are based on sampling object space 
\cite{Arnold:OOPSLA08}, sampling time \cite{BartocciGKSSZS12, StollerBSGHSZ11},
and sampling properties \cite{dwyer08ase}. 
Among these approaches, the one presented by Arnold et al.  
\cite{Arnold:OOPSLA08} is closest to us in its spirit. They develop Quality 
Virtual Machine (QVM) that tracks safety properties, Java assertions and heap 
properties for violations. It also has an overhead manager to enforce a user 
specified overhead budget. Even though effective for general-purpose 
applications, QVM is not designed for real-time system requirements. It is not 
easily portable and it apparently tracks only single-object properties. Similar 
to our approach none of these systems sacrifices completeness for sampling. 
However, unlike our approach none of these systems reuse monitors.
\\
\textbf{\textit {Aspect-based and similar monitoring approaches}} A number of 
finite state runtime monitoring tools including Tracematches \cite{Allan:OOPSLA05},
JavaMOP \cite{meredith-2008}, and MARQ \cite{Reger2015}
have been developed to detect violations of typestate properties. 
JavaMOP in particular has been expressive in terms of its specification power 
and supports various formalisms ranging from regular expressions to context-free 
grammars. It converts its specification to an aspect which is then woven into a 
program to be monitored. Due to the flexibility in its architecture  JavaMOP 
allows various optimizations to be performed making it an efficient monitoring 
tool. In spite of this efficiency, for certain program and property 
combinations, all of these tools incur heavy and unbounded overheads in terms of 
memory and time. These scenarios act as the motivation to our research. Various 
approaches \cite{Avgustinov:2007, luo-2014, meredith-2008, Purandare:2013} have been proposed to control the memory as well as avoid 
unnecessary monitoring that cannot lead to any errors. However, in spite of 
these 
efforts and the effectiveness of their approaches, runtime monitoring still 
remaining challenging particularly finite state properties.


\ignore{
\\In [15], Avgustinov et al. identify two optimizations, a combination of leak 
elimination and indexing, that analyse the tracematch's specified declarative 
pattern and not the monitored code itself. One of the optimizations is 
discarding the unnecessary monitors which could improve the memory behaviour and 
avoids space leaks. The authors have identified that the performance of garbage 
collector affects the optimisation. In other words, if a program runs with 
smaller heap, the garbage collector runs all the time and thus perform better 
than programs with larger heap. The second optimisation is a form of indexing of 
the set of monitors for their efficient tracking. The indexing also eliminates 
the crucial dependency on garbage collector performance. On evaluating with a 
few benchmark-property combinations, it shows significant speed ups in many 
cases but similar or even worse performance in few other combinations.
\\
Alternatively, in  the authors propose garbage collection of unnecessary monitor 
instances to prune the unnecessary monitors based on static analysis of the 
monitored property. If an object is garbage collected, then the monitor instance 
binded to that object becomes unnecessary. The information of garbage collection 
of parameter objects is propogated and the unnecessary monitors are removed 
lazily to avoid creating undue overhead. The RV system builds upon the Indexing 
Tree Technique of the JavaMOP system to access the objects and related monitors. 
Garbage collection of unnecessary monitors reduces memory usage and the time 
required to update monitor instances. The average overhead of RV on evaluating 
with Dacapo Benchmarks [11] for various safety properties is lower than JavaMOP 
and Tracematches. We, on the contrary, are not using static analysis but 
maintaining a pool of monitor instances that will be reused to ensure less 
memory usage and at the same time check for typestate property violations.
}

\textbf{\textit {Hybrid approaches}} Several hybrid approaches have been 
proposed by research that combine static program analysis with dynamic program 
analysis \cite{Bodden:ECOOP07, bodden:fse08, bodden:icse10, Bodden:RV10, Dwyer:ASE07, Purandare:OOPSLA10}.
The static component of the analysis essentially filters the 
program points that do not need to be monitored. These approaches are effective, 
and have been found to control time overheads up to certain extent but also have 
been found to be unsatisfactory in many cases. Moreover, they have not been 
effective in controlling the space requirements. Moreover, none of these 
approaches can provide bounds on the execution times of monitoring operations. 
The usage of static analysis can often be unsatisfactory due to numerous false 
positives and can be time-consuming adversely impacting the development and 
analysis of the software.
\\

