\section{Implemetation and Artifacts}
\label{sec:implementation}

Our implementation is semi-automatic and is based on the refinement of the 
aspects generated by JavaMOP 2.3. The reason for choosing an older version of 
JavaMOP was that it is simple to understand and it performs less optimizations. 
Hence, the chance of interfering the existing optimizations with our approach is 
less. This would not have been possible if we did not have a good understanding 
of the aspects consumed by our prototype implementation. Moreover, we compare 
the results of our work with JavaMOP 2.3 as well as JavaMOP 3.0 which is a much 
newer version of JavaMOP. 
%The aspects are then woven using ajc 1.7 compiler, and 
%the resulting Java program is executed on HPC server running Cent OS 6.5 and
% JVM 1.7.0. 

We referred to previous studies \cite{}, and identified a few challenging DaCapo 
benchmarks and Java standard library property combinations that have been found 
difficult to b consuming a large amount of memory. Hence, we chose three DaCapo 
benchmarks \textsf{avrora}, \textsf{bloat}, and \textsf{pmd}. The benchmark 
\textsf{avrora} was taken from DaCapo 2010 benchmark suite since it was not 
apart of the 2006 benchmark suite, whereas the other two were taken from the 
2006 benchmark suite since \textsf{bloat} was not a part of the 2010 benchmark 
suite. We chose two properties \texttt{HasNext} and \texttt{UnsafeIterator} 
described in Section~\ref{sec:motivation} since they were found to be generating 
a large number of monitors. Property \texttt{HasNext} was particularly useful 
since two of the three benchmarks reported property violations which we could 
use for the comparison in our study. For this property, we added an extra 
\textit{creation} event for the convenience so that the monitor creation happens 
only  for the first time the system encounters the object. Property 
\texttt{UnsafeIterator} already had a well-defined creation event.


\subsection{DaCapo instrumentation} 
\label{subsec:dacapoInstr}

We have used \texttt{Soot}~\cite{soot} to
instrument Dacapo benchmarks. \code{getStackTrace()} method can be used to
fetch current stack trace but it introduces overhead. To mitigate this, we have
instrumented each of the methods of DaCapo benchmark with a static
\code{integer} field which is populated with an unique method id represented by
a $16$ bit \code{integer}. We have also simulate the stack trace by using a
circular array which contains these method id's. The circular array is
implemented by a $64$ bit \code{long}. A pseudo code of the method stack is
described in Code~\ref{snippet:methodTrace}.

\lstset{escapeinside={/*@}{@*/}, language=Java , caption=\bf Method trace
implementation., label=snippet:methodTrace} \begin{figure}[t]
\begin{lstlisting}
long trace; //method stack trace	
int counter = 0;
void methodTrace(int methodID) {
 switch (counter) {
  case 0: id <<= 32; break;
  case 1: id <<= 16; break
  case 2: id <<= 0; break;
  default: break;
 }
 trace |= id;
 trace &= 0xffffffffffffL;
 counter = (counter + 1) % traceLength;
}
\end{lstlisting}
\end{figure}

\subsection{Aspect Generation and Optimizations}
\label{subsec:aspectGen}

\subsection{Context Matching}
\label{subsec:contextMatch}
The time and memory overheads have been reported after using -converge option 
provide by the DaCapo benchmark suite.