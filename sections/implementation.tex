\section{Implemetation and Artifacts}
\label{sec:implementation}

We have developed a semi-automatic prototype to optimize the \texttt{Aspect}
generated by \textsc{JavaMop}.


%The aspects are then woven using ajc 1.7 compiler, and 
%the resulting Java program is executed on HPC server running Cent OS 6.5 and
% JVM 1.7.0. 

\subsection{\textsc{DaCapo} instrumentation} 
\label{subsec:dacapoInstr}

We have used \texttt{Soot}~\cite{soot} to
instrument \textsc{DaCapo} benchmarks. \code{getStackTrace()} method can be used to
fetch current stack trace but it introduces overhead. To mitigate this, we have
instrumented each of the methods of \textsc{DaCapo} benchmark with a static
\code{integer} field which is populated with an unique method id represented by
a $16$ bit \code{integer}. Code snippet~\ref{snippet:instrument} provides one
example method and it's instrumented counterpart.

\lstset{escapeinside={/*@}{@*/}, language=Java , caption=\bf Method trace
implementation., label=snippet:instrument} \begin{figure}[t]
\begin{lstlisting}
void foo(){		//original method
..   //some code
}
void foo(){		//instrumented method
static int methodID = 0x1a;
MethodTrace.insertMethodTrace(methodID);
..   //some code
}
\end{lstlisting}
\end{figure}

\subsection{Lightweight Method Trace}
\label{subsec:trace}

We have also simulate the stack trace by using a
circular array which contains these method id's. The circular array is
implemented by a $64$ bit \code{long} in the format $id_i|id_j|id_k$, where
$id_i$ is the method id corresponding to method $\code{f}_i$ and is a $16$ bit
integer. A pseudo code of the method stack is described in
Code~\ref{snippet:methodTrace}.

\lstset{escapeinside={/*@}{@*/}, language=Java , caption=\bf Method trace
implementation., label=snippet:methodTrace} \begin{figure}[t]
\begin{lstlisting}
long trace; //method stack trace
int counter = 0;
void insertMethodTrace(int methodID) {
 switch (counter) {
  case 0: id <<= 32; break;
  case 1: id <<= 16; break
  case 2: id <<= 0; break;
  default: break;
 }
 trace |= id;
 trace &= 0xffffffffffffL;
 counter = (counter + 1) % traceLength;
}
\end{lstlisting}
\end{figure}
The stack trace (\texttt{trace} in code~\ref{snippet:methodTrace}) is populated
by bit-wise \texttt{shift} and \texttt{OR} operation. This makes any query
operation over the stack-trace very light weight compared to traditional
\texttt{getStackTrace()} call.

\subsection{Aspect Generation and Optimizations}
\label{subsec:aspectGen}

Our implementation is semi-automatic and is based on the refinement of the 
aspects generated by JavaMOP 2.3. The reason for choosing an older version of 
JavaMOP was that it is simple to understand and it performs less optimizations. 
Hence, the chance of interfering the existing optimizations with our approach is 
less. This would not have been possible if we did not have a good understanding 
of the aspects consumed by our prototype implementation. Moreover, we compare 
the results of our work with JavaMOP 2.3 as well as JavaMOP 3.0 which is a much 
newer version of JavaMOP. We optimize \textsc{JavaMop} generated aspects by
adding statements to the particular \code{pointcut} which are responsible for
monitor creation. A \code{HashMap} named \code{contextMonitorMap} is added to
the aspect which is a mapping between a specific context (\code{long}) and an
\code{ArrayList} of monitors associated to that context. Additionaly we have
added a method named \code{getProbabilityVal()} to determine the probability of
creating a monitor in runtime depending on the number of monitors associated to
a specific context (getching from \code{contextMonitorMap}). We have also added
additional \code{pointcut} to measure evaluation parameters such as \#monitor,
\#events, time and memory consumption of the events individually.


\subsection{Context Matching}
\label{subsec:contextMatch}

Context matching codes are written inside the \code{pointcut} which are
responsible for monitor creation. Runtime method context can be determined by
looking at the \code{trace} variable (code~\ref{snippet:methodTrace})) which
represents current calling context. \code{trace} contains 

The time and memory overheads have been reported after using -converge option 
provide by the \textsc{DaCapo} benchmark suite.