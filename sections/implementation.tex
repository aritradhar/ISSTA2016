\section{Implementation}
\label{sec:implementation}

% We have developed a semi-automatic prototype to optimize the \texttt{Aspect}
% generated by \textsc{JavaMop}. The specific details of the implementation is
% provided below.

We implement a prototype of our approach (as described in~\xref{sec:approach}) 
in \textsc{Java}. We use \soot~\cite{soot} for program instrumentation, 
and leverage the \code{ajc} v$1.7$ compiler to weave aspects. The prototype
is written entirely in \java in $3532$ lines of code (\soot\ instrumentation
module $334$ and aspect implementation $3198$). We below mention a few other
salient features of our implementation.
%\note{How many lines of Java code did it involve?}

%The aspects are then woven using ajc 1.7 compiler, and 
%the resulting Java program is executed on HPC server running Cent OS 6.5 and
% JVM 1.7.0. 

% \subsection{\textsc{DaCapo} instrumentation} 
% \label{subsec:dacapoInstr}
% 
% We have used \texttt{Soot}~\cite{soot} to
% instrument \textsc{DaCapo} benchmarks. 

\subsection{Lightweight Execution Context}
\label{subsec:trace}

\lstset{escapeinside={/*@}{@*/}, language=Java , caption=\bf Method 
instrumentation., label=snippet:instrument} \begin{figure}[t]
\begin{lstlisting}
void foo(){		//original method
..   //some code
}
void foo(){		//instrumented method
static int methodID = 0x1a;
MethodTrace.insertMethodTrace(methodID);
..   //some code
}
\end{lstlisting}
\end{figure}

While \code{getStackTrace()} fetches the current stack trace, it introduces 
significant performance penalties. To mitigate this overhead, we instrument 
every program method with a static \code{Integer} field and populate it with a 
unique $16$ bit method identifier. Code~\ref{snippet:instrument} shows an 
example snippet and its instrumented counterpart.
% 
% 
% \subsection{Lightweight Method Trace}
% \label{subsec:trace}

\lstset{escapeinside={/*@}{@*/}, language=Java , caption=\bf Light-weight 
execution context., label=snippet:methodTrace} \begin{figure}[t]
\begin{lstlisting}
long trace; //method stack trace
int counter = 0;
void insertMethodTrace(int methodID) {
 switch (counter) {
  case 0: id <<= 32; break;
  case 1: id <<= 16; break
  case 2: id <<= 0; break;
  default: break;
 }
 trace |= id;
 trace &= 0xffffffffffffL;
 counter = (counter + 1) % traceLength;
}
\end{lstlisting}
\end{figure}

We simulate the stack trace by using a circular array containing these method 
identifiers. The circular array is implemented as a $64$ bit \code{Long} 
integer. The array is of the format $id_i|id_j|id_k$, where $id_i$ is the 
method id corresponding to method $\code{f}_i$ and is a $16$ bit integer. A 
pseudo code of the method stack is described in Code~\ref{snippet:methodTrace}. 
Note that the stack trace is populated by bit-wise \code{<<} and \code{|} 
operations, which makes any query operation over the stack-trace very light 
weight compared to traditional \texttt{getStackTrace()} call.

\subsection{Aspect Generation and Optimizations}
\label{subsec:aspectGen}

Our implementation is based on refinement of aspects generated by 
\textsc{JavaMOP} v$2.3$. 
% We use an older version of \textsc{JavaMOP} since it was much more simple 
% understand and it performs less optimizations. Hence, the chance of interfering 
% the existing optimizations with our approach is less.
% 
% \note{not a fair justification 
% of why use v2.3.}
% 
% This would not have been 
% possible if we did not have a good understanding 
% of the aspects consumed by our prototype implementation. Moreover, we compare 
% the results of our work with JavaMOP 2.3 as well as JavaMOP 3.0 which is a much 
% newer version of JavaMOP.
We optimize \textsc{JavaMop} generated aspects by adding statements to the 
particular \code{pointcut} responsible for monitor creation. A \code{HashMap} 
 is added to the aspect that maps between a specific context (\code{long}) and 
an \code{ArrayList} of monitors associated to that context. Additionally, we 
 determine the probability of creating a monitor (see code snippet in
 Code~\ref{getProbabilityVal}) at runtime depending on the number of  monitors
 associated to a specific context. %\note{but how is the probability
 % calculated?} 
 We also add additional \code{pointcut}'s to measure evaluation parameters such 
 as \#monitor, \#events, time and memory consumption of the events individually.

\lstset{escapeinside={/*@}{@*/}, language=Java , caption=\bf
\code{getProbabilityVal} implementation., label=getProbabilityVal}
\begin{figure}[h]
\begin{lstlisting}
double getProbabilityVal(int counetr)
{
  if(count >= 0 && count < 1000) return 1;
  else if(count >= 1000 && count < 5000) return 0.5;
..
}
\end{lstlisting}
\end{figure}

\myparagraph{Context Matching} Context matching is written within the 
\code{pointcut} responsible for monitor creation. Runtime method context is 
determined using the \code{trace} variable (see 
Code~\ref{snippet:methodTrace})), which represents the current calling context. 
Thus, each monitor is associated with a unique context value. Whenever a new 
monitor creation \code{pointcut} is encountered, the context matching module 
checks the number of monitor associated with that context and probabilistically 
decides whether to allocate more monitors or not.

% The time and memory overheads have been reported after using -converge option 
% provide by the \textsc{DaCapo} benchmark suite.