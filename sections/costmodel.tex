\section{Cost Model}
\label{sec:costmodel}

Monitoring tools perform several operations that include monitor creation, maintain their pool, tracking the associated monitors and executing a transition on them. Depending on the number of monitors created and the number of events incurred, all these operations incur a cost. The whole operation of handling events may become non-deterministic as far as timing requirements are concerned because the number of monitors associated with an object grow uncontrollably. Thus, it becomes difficult to predict the time taken to execute the monitoring operation . In this section we present a cost model that can give designer an idea about the overheard incurred by our framework for runtime monitoring. Our model is guided by the model defined in [12] and the basic definitions and symbols are adopted from the earlier study [12].
\section{Basic Definitions:}
Let $\phi$ = (Q,$\Sigma$,$\delta$,$q_{0}$,F) be the FSA for the property being monitored and $\pi$ the trace of events generated by a program execution related to $\phi$. The event, $e_{i}$, is a pair ($b_{i}$, $l_{i}$) where $b_{i}$ $\epsilon$ $\Sigma$, the set of FSA symbols and $l_{i}$ is set of objects associated with $e_{i}$. Let E be the set of events where E consists of two types of events, $E_{c}$ $\subseteq$ E, the set of monitor creation events which corresponds to an event that creates a monitor and $E_{c} \subseteq$ E, the set of binding events that bind new objects to the old ones that already have associated monitors. The binding events clone the existing monitors associated with old objects to create new monitors. The set of objects $l$ involved in a binding event is divided into two partitions $l_{b}$, set of old objects already associated with monitors and $l_{\overline b}$, set of objects of the binding event.\\\\
 L = \{{$\tau_{b}$ : b $\in$ $\Sigma$}\} where L is defined as the set of sets of types of objects that may be associated with all symbols and  ЅСb the set of types of objects that may be associated with the symbol b. For example, L= \{\{Iterator\},\{Collection\},\{Collection,Iterator\}\} for the property UnsafeIterator.\\
We considered the following points while developing the cost model:
\begin{itemize}
\item The monitors are created in creation event and a pool of monitors is maintained and then they may be reassigned. Once the total number of monitors reaches the limit, monitors can be retrieved from the pool of monitors and reassigned to another object after deleting the references of previous object(s). The total number of monitors used for monitoring is fixed.
\item In order to provide fast access to monitors, the monitoring tool support indexing scheme. For each subset of $\sum$?ал that has same object types, an index map is created and set of all such maps is denoted by {$\Psi_{\phi}$}
\item For method call matching, the history of method call is abstracted by getStackTrace() and a data structure is maintained to keep track of the sequence of these calls. In case a match is not found, monitoring of the associated object will be performed.
\end{itemize}
\section{Cost Models:}
Detailed cost models are presented in this sub section that predicts the cost of runtime monitoring. The cost of monitoring, $C_{m}$ for $\phi$ gives the additive cost of processing each event which may vary depending on whether it is a creation event or not.
\begin{center}
$C_{m}$ = $\displaystyle \sum_{i=1}^{|\pi|}f(\pi_{i})$
\end{center}
The distinct components of the cost of processing an event are identified as below:
\begin{enumerate}
\item $C_{C}$ : Cost of creating monitors.
\item $C_{ST}$ : Cost of abstracting method call history.
\item $C_{TM}$ : Cost of call trace matching.
\item $C_{A}$ : Cost of maintaining monitor array.
\item $C_{R}$ : Cost of accessing and manipulating index trees.
\item $C_{I}$ : Cost of inserting monitors into pools.
\item $C_{V}$ : Cost of traversing monitor pools.
\item $C_{T}$ : Cost of performing transitions.
\end{enumerate}
Thus, the cost of processing the $i^{th}$ event is given by
\begin{center}
f($\pi_{i}$) = $C_{C}(\pi_{i})$+$C_{ST}(\pi_{i})$+$C_{TM}(\pi_{i})$+$C_{A}(\pi_{i})$+$C_{R}(\pi_{i})$+$C_{I}(\pi_{i})$+$C_{V}(\pi_{i})$+$C_{T}(\pi_{i})$
\end{center}

The total number of events do not matter but the individual events are all bounded in our approach.

\subsection{$C_{C}$ : Creating Monitors}
This cost is incurred in performing step 18 of the algorithm.To begin monitoring of $\phi$ for a set of related objects, monitor creation events, $E_{c} \subseteq$ E occur. We have put a limit on the number of monitors generated for making monitoring memory efficient. For creation events, if the number of total monitors is less than the limit, a monitor must be created and then inserted into the appropriate indexing structure. $|l_{i}|$ * $c_{c_{m}}$ reflects the cost of creating a monitor component, $c_{c_{m}}$, for each of the objects in the event, $|l_{i}|$. As mentioned earlier, monitors will be created only if the total number of monitors is less than the limit. So, the number of monitors created in the creation event will always be less than or equal to limit specified, thus providing the worst case bound.

For binding events, the monitors that are already associated with $l_{b}$ are cloned and clones are associated with $l_{\overline b}$. P is defined as a function that takes a monitor and a prefix of the trace $\sigma_{i}$ as input and outputs the set of monitor components.
Thus, 
\begin{center}
$C_{C} = \begin{cases}
			\displaystyle \sum_{m\epsilon \theta (l_{i_{b}},\pi_{i})}^{|l_{i}|*c_{c_{m}}} {|P(m,\pi_{i}) \cup l_{i}| * c_{c_{m}}} & e_{i} \epsilon E_{c} \lor E_{b} \\
            0 & otherwise
         \end{cases}$
         
\end{center}

Note, the binding events are present in \textit{UnsafeMapIterator} property and not in \textit{HasNext} or \textit{UnsafeIterator} property.
\subsection{$C_{ST}$ : Retrieving method call history}
This cost is incurred in performing step 9 of the algorithm. Every object undergoes various method calls in its lifetime. Here, we need to track the methods invoked on the object. The extraction of the method calls history is the most important step in our approach because it helps in deciding if monitoring is required. The cost associated with this step is constant and depends on the underlying JVM. Let $\eta : l_{c} \to ST$ (where ST is the Stack Trace) be a function that inputs object associated with the create event and outputs the method call trace.\\
\begin{center}
$C_{ST}=|l_{c}| * c_{st}$ \hspace{16pt}  $e_{i} \in E_{c}$
\end{center}
Note, this cost is associated with creation event only.


\subsection{$C_{TM}$ : Method Call Trace Matching}
This cost is incurred by step 11 of the algorithm.The extracted history of method calls are stored in an appropriate data structure. For each object related to the creation event, this data structure needs to be accessed in order to check if there exists previously created monitors associated with some object having the same call history. The cost of traversing and matching a method call from the data structure be $c_{tm}$. If a method call is not present in the data structure, it needs to be added, thus incuring the cost, $c_{am}$. We define a function $\xi$ which takes a datastructure as input and outputs a cost of traversing a method call. Formally,
\begin{center}
$\xi(m) = \begin{cases}
			c_{tm} & method call$ present$\\
            c_{tm} + c_{am} & otherwise
          \end{cases}$  
\end{center}
Thus,
\begin{center}
$C_{TM}=|\eta(l_{c})| * \xi(m)$ \hspace{20pt}  $e_{i} \in E_{c}$ 
\end{center}

\subsection{$C_{A}$ : Maintaining Monitor Array}
This cost is incurred by step 17 - 20 of algorithm. While processing a creation event, we maintain an array of monitors that has a specified limit. Whenever monitoring is to be performed, a check on the size of array is done to ensure the limit. If the size is below the limit, a new monitor is inserted in the array; the cost of insertion is $c_{ia}$. However, the cost changes to $c_{ra}$ if the size exceeds the limit as the monitors will be reassigned.
\begin{center}
$C_{A} \leq \begin{cases}
			limit * c_{ia} & sizeOf(array) \le limit\\
            limit * c_{ra} & otherwise
          \end{cases}$
\end{center}

\subsection{$C_{R}$ : Index Trees}
Object based monitoring incurs the cost of retrieving object maps but the associated costs arise in different ways. Let $\psi \in \Psi_{\phi}$ be some index tree and $\nu$ be a map. $\Psi_{\phi}$ can be partitioned into $\Psi'_{\phi}$, set of index trees for all objects involved in creation event ($\rho(\phi)$) and $\Psi''_{\phi}$, be the additional index trees for the objects that are involved in binding events. These additional index trees provides access to the already existing monitors for binding objects.
\begin{center}
$\Psi_{\phi} = \begin{cases}
			 \Psi'_{\phi} & \rho(\phi)\\
             \Psi'_{\phi} \cup \Psi''_{\phi} & otherwise
          \end{cases}$  
\end{center}
We denote the number of maps accessed in processing an event by a function H that takes an event and set of index maps and outputs the number of maps. On the basis of program context, we sample the objects to be monitored. If a decision is taken in creation event to skip monitoring, this cost is not incurred in non-creation events. However, this cost is incurred in creation event. In the worst case, every subset of L may have corresponding index trees which can be at max $\displaystyle \sum_{k=1}^{|L|} 2^{k}$, thus putting bound on H. So, the number of object maps to be accessed given by \textit{$H(e_{i}, \Psi_{\phi})$} can not be larger than this bound.   Let $c_{r}$ be the cost of retrieving a value from such map, $c_{c_{p}}$ be the cost of creating a map and that of adding an entry to a map is $c_{a{p}}$. We define $\kappa$ a function that takes a map and outputs a cost of adding an entry to it, if required. 

\begin{center}
$C_{R} = \begin{cases}
			 H(e_{i},\Psi_{\phi}) * c_{r} + \displaystyle \sum_{\nu \in H(e_{i},\psi_{phi})} \kappa(\nu) & e_{i} \in E_{c} \cup E_{b} \\
             H(e_{i},\Psi_{\phi}) * c_{r} & otherwise
          \end{cases}$  
\end{center}

\subsection{$C_{I}$ : Inserting Monitors}
Everytime a new monitor is created while processing a creation event, it has to be inserted into each of the index maps, the cost of insertion is, $c_{a_{m}}$. However, the cost changes for a binding event where all the cloned monitors need to be inserted in the map. Function G would give us the number of index trees that will be accessed to retrieve the monitor pools in which the new monitor will be inserted. The total cost incured is given by
\begin{center}
$C_{I} = \begin{cases}
			 |\Psi_{\phi}| * c_{a_{m}} & e_{i} \in E_{c} \\
             |G(l_{i},\Psi_{\phi})| * c_{a_{m}} & e_{i} \in E_{b} \\
             0 & otherwise
          \end{cases}$  
\end{center}

\subsection{$C_{V}$ : Traversing Monitors}
There are no pre existing monitors related to the event while handling a creation event corresponding to a creation symbol and thus no traversal cost. For other events, $\theta$ is defined to be the number of monitors associated with a set of objects for the trace $\pi_{i}$. Each monitor is accessed individually with a cost of $c_{v}$. This cost is incurred only when the decision of monitoring is taken in creation event. Thus
\begin{center}
$C_{V} = \begin{cases}
			 0 & e_{i} \in E_{c} \\
             0 & \sim(monitoring) \\
             \theta(l_{i},\pi_{i}) * c_{v} & otherwise
          \end{cases}$  
\end{center}

\subsection{$C_{T}$ : Performing Transitions}
There are no transitions as the creation events are initialized to an appropriate state. For non creation events, each monitor for the event is accessed and performs a transition on the stored FSA state, which costs $c_{t}$. Also, there are no transitions if the monitoring is skipped. Thus
\begin{center}
$C_{T} = \begin{cases}
			 0 & e_{i} \in E_{c} \\
             0 & \sim(monitoring) \\
             \theta(l_{i},\pi_{i}) * c_{t} & otherwise
          \end{cases}$  
\end{center}




