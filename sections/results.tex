\section{Evaluation}
\label{sec:evaluation}

We now describe an evaluation of our approach.

\xref{sec:evaluation:rq} lists all the research questions we address in this
paper .In~\xref{sec:evaluation:resource} and~\xref{sec:evaluation:bounded} we
describe memory consumption and time data respectively of our optimized aspects approach compared to the original \textsc{JavaMop} generated aspects. 
\xref{sec:evaluation:effectiveness} shows the amount of errors reported by our
optimized aspects.

\subsection{Research questions} 
\label{sec:evaluation:rq}

\begin{mybullet}
 \item[\textbf{RQ1}] Does our approach consume less memory?
\item[\textbf{RQ2}] Does it incur overall higher time overhead (in comparison
with the unoptimized approach)?
\item[\textbf{RQ3}] Does our approach bound worst case execution time for all
monitoring operations?
\item[\textbf{RQ4}] Does our approach effectively catch errors or
does it compromise with error reporting?
\end{mybullet}



\myparagraph{Experimental Setup} 

We ran all our experiments on a laptop with $2.5$ GHz processor and $16$ GB RAM
running OS Windows 7 64-bit. We use JVM version $8$ update $60$ with allocated heap size of $8$ GB, \aspectj\ compiler version $1.8.7$ and
\soot\ version $2.5.0$. For evaluation purpose, we use \dacapo\
benchmark version $2006-10-MR2$ \& $9.12$. We use both $\textsc{JavaMop}$ versions
$2.3$ and $3.0$ to generate aspects on top of which we wrote our optimizations.
We have considered four benchmarks from \dacapo\ benchmark suite which
are \bloat, \pmd, \chart\ and \avrora. We have ignored rest of the benchmarks as
they do not contain sufficient monitor event. For type-state property, we
consider \hasnext, \unsafeiter\ and \hashset. 



\begin{table*}[!ht]
\centering
\scriptsize
\begin{tabular}{|c|c|c|c|c||c|c|c|c||c|c|c|c|}
\hline
  \multirow{2}{*}{}                                 & 
\multicolumn{4}{c||}{HasNext}           & \multicolumn{4}{c||}{FailSafeIter}
   &    \multicolumn{4}{c|}{HashSet}
      \\ \cline{2-13}                                              
           
           
 & bloat & pmd & chart & avrora & bloat & pmd & chart & avrora& bloat
 & pmd & chart & avrora\\ \hline
 
  Original  & $20694$ & $15551$ & $7074$ & $52825$ & $23471$ & $20688$ & $6909$
  & $56873$ & $16031$ & $17017$ & - & $52895$\\\hline
 
 Optimized ($\mathcal{L}(A) = 1$K)  & $13225$ & $13891$ & $6293$ & $52857$ &
 $18406$ & $13249$ & $6960$ & $55314$ & $16681$ & $17940$ & - & $54080$\\\hline
  
  Optimized ($\mathcal{L}(A) = 30$K)  & $15161$ & $14953$ & $6794$ & $53305$ &
  - & - & - & - & - & - & - & -\\\hline
     

\end{tabular}
\caption{Runtime (ms.) of \dacapo\ benchmarks, $\mathcal{L}(A)$ denotes
\#error reported.}
\label{table:time}
\end{table*}


\begin{table*}[!ht]
\centering
\scriptsize
\begin{tabular}{|c|c|c|c|c||c|c|c|c||c|c|c|c|}
\hline
  \multirow{2}{*}{}                                 & 
\multicolumn{4}{c||}{HasNext}           & \multicolumn{4}{c||}{FailSafeIter}
   &    \multicolumn{4}{c|}{HashSet}
      \\ \cline{2-13}                                              
           
           
 & bloat & pmd & chart & avrora & bloat & pmd & chart & avrora& bloat
 & pmd & chart & avrora\\ \hline
 
  Original  & $0.85$ & $0.8$ & $0.45$ & $1.1$ & 
              $0.85$ & $0.9$ & $0.32$ & $1.2$ & 
              $0.79$ & $0.89$ & - & $1.1$\\\hline
 
 Optimized ($\mathcal{L}(A) = 1$K)  & 
 			$0.49$ & $0.49$ & $0.4$ & $0.8$ &
 			  $0.77$ & $0.52$ & $0.29$ & $0.7$ & 
 			  $0.5$ & $0.49$ & - & $0.6$\\\hline
  
  Optimized ($\mathcal{L}(A) = 30$K)  & 
  $0.52$ & $0.51$ & $0.4$ & $0.8$ &
  - & - & - & - &
   - & - & - & -\\\hline
     

\end{tabular}
\caption{Peak Memory consumption (in GB)}
\label{table:memory}
\end{table*}



\begin{table*}[!ht]
\centering
\scriptsize
\begin{tabular}{|c|c|c||c|c||c|c||c|c|}
\hline
\multicolumn{9}{|c|}{\bf\code{HasNext}}\\\hline
\multirow{3}{*}{}               & \multicolumn{2}{c||}{bloat}             & 
\multicolumn{2}{c||}{pmd}            & \multicolumn{2}{c||}{chart}      & 
\multicolumn{2}{c|}{avrora} \\\cline{2-9} 
& $\mathcal{N}(E)/\mathcal{N}(C)$  & $\mathcal{N}(A)$ &
$\mathcal{N}(E/\mathcal{N}(C))$  & $\mathcal{N}(A)$ &
$\mathcal{N}(E)/\mathcal{N}(C)$  & $\mathcal{N}(A)$ &
$\mathcal{N}(E)/\mathcal{N}(C)$  & $\mathcal{N}(A)$ 
\\ \hline
 
 Original   & $44/3$ & $1.9$M & $400/3$ & $1.94$M & $0$ & $817$ & $7.9$K$/9$&
 $898$K
 \\
 \hline Optimized ($\mathcal{L}(A) = 1$K) & $3/3$  & $10$K  & $322/3$ & $10$K 
 & $0$ & $101$ & $726/9$ & $8.2$K
 \\
 \hline Optimized ($\mathcal{L}(A) = 30$K) & $3/3$  & $110$K & $390/3$ &
 $224$K & $0$ & $817$ & $10.3$K $/9$ & $119$K
 \\
 \hline \multicolumn{9}{|c|}{\bf\code{FailSafeIter}}\\\hline
  Original  & $0$     & $1.96$M&  $0$ & $1.94$M & $0$ & $817$ & $0$& $898$K  \\
  \hline Optimized ($\mathcal{L}(A) = 1$K) & $0$ & $20$K & $0$ & $20$K & $0$ & $324$ &
 $0$ & $16.7$K \\\hline
 %Optimized ($\mathcal{L}(A) = 30$K) & $0$ & $220$K & $0$ & $449$K & $0$ &
% $324$ & $0$ & $167$K \\\hline
 %Optimized2 & & & & & & & &  \\ \hline
 \multicolumn{9}{|c|}{\bf\code{HashSet}}\\\hline
  Original  & $0$     & $11.8$K& $0$ & $7.7$ K & - & - & $0$& $8$ \\ \hline
 Optimized($\mathcal{L}(A) = 1$K) & $0$ & $5.3$K & $0$ & $408$ & - & - & $0$&
 $8$
 \\
 \hline
 %Optimized($\mathcal{L}(A) = 30$K) & $0$ & $5.3$K & $0$ & $408$ & - & - & $0$&
% $8$
 %\\
 %\hline
 %Optimized2 & & & & & & & &  \\ \hline
 
\end{tabular}
\caption{Errors reported and monitors generated for different properties.
$\mathcal{N}(E)$, $\mathcal{N}(C)$ $\mathcal{N}(A)$ and $\mathcal{L}(A)$ denote
\#error reported, \#unique contexts where errors are encountered, \#monitor
allocation and \#monitor limit respectively.}
\label{table:errorreporting1}
\end{table*}



\begin{table*}[!ht]
\centering
\scriptsize
\begin{tabular}{|c|c|c|c|c|c|c||c|c|c|c|c|c|}
\hline
\multirow{1}{*}{}                                                                
     & \multicolumn{6}{c||}{\bf Original aspect} & 
\multicolumn{6}{c|}{\bf Optimized aspects} \\ \cline{1-13} 
                                                                                 
 \multirow{3}{*}{\bf HashSet property}    & \multicolumn{2}{c|}{\bf add}  &
 \multicolumn{2}{c|}{\bf remove} & \multicolumn{2}{c||}{\bf contain} &
 \multicolumn{2}{c|}{\bf add}   &
 \multicolumn{2}{c|}{\bf remove} & \multicolumn{2}{c|}{\bf contain}         \\
 \cline{2-13} & max & min & max & min & max & min & max & min & max & min & max & min
 \\\cline{2-13}  
 &  $11$ & $1$   &   $3$     & $1$   &  $1$   & $1$   &   $1$    & $1$   &  $1$   
 & $1$ & $2$ & $1$\\\hline
 
  \multirow{3}{*}{\bf UnsafeIter property}    & \multicolumn{2}{c|}{\bf create} 
  & \multicolumn{2}{c|}{\bf update} & \multicolumn{2}{c||}{\bf next} &
 \multicolumn{2}{c|}{\bf create}   &
 \multicolumn{2}{c|}{\bf update} & \multicolumn{2}{c|}{\bf next}         \\
 \cline{2-13} & max & min & max & min & max & min & max & min & max & min & max & min
 \\\cline{2-13}  
 &  $1592$ & $1$   &   $65$     & $1$   &  $5$   & $1$   &   $37$    & $1$   & 
 $2$ & $1$ & $80$ & $1$\\\hline
 
   \multirow{3}{*}{\bf HasNext property}    & \multicolumn{3}{c|}{\bf hasNext} 
   & \multicolumn{3}{c||}{\bf next} &
 \multicolumn{3}{c|}{\bf hasNext}   & \multicolumn{3}{c|}{\bf next} \\
 \cline{2-13}
 
 & \multicolumn{1}{c|}{max} & \multicolumn{2}{c|}{min} &  
 \multicolumn{1}{c|}{max} & \multicolumn{2}{c||}{min} &
 \multicolumn{1}{c|}{max} & \multicolumn{2}{c|}{min} &
 \multicolumn{1}{c|}{max} & \multicolumn{2}{c|}{min}  \\\cline{2-13}  
 &   \multicolumn{1}{c|}{$944$} & \multicolumn{2}{c|}{$1$}   &  
 \multicolumn{1}{c|}{$89$} & \multicolumn{2}{c||}{$1$} &  
 \multicolumn{1}{c|}{$3$}   & \multicolumn{2}{c|}{$1$}   & 
 \multicolumn{1}{c|}{$10$}   & \multicolumn{2}{c|}{$1$}   \\\hline
 
 

\end{tabular}
\caption{Comparison of event times(ms) of \dacapo\ \bloat.}
\label{table:eventTime}
\end{table*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Resource Consumption}
\label{sec:evaluation:resource}

% \note{Add stuff about \\
% Q1 Does our approach consume less memory?
% Q4 Does it incur overall higher time overhead (in comparison with the 
% unoptimized approach)?\\
% Web server experiment?
% }

Here we address \textbf{RQ1} and \textbf{RQ2} (refere~\xref{sec:evaluation:rq})
which talk about resource consumption of our approach compared to the aspects
generated by \textsc{JavaMop}. Resource consumption data is represented in terms
of runtime and main memory consumption, which is tabulated in the
Tables~\ref{table:time} and ~\ref{table:memory}. Table~\ref{table:time}
tabulates all the run time of benchmark execution in ms. For comparison, we use
the aspect generated by \javamop\ which is denoted as \emph{Original} in the
table. \emph{Optimized($\mathcal{L}(a) = 1K$)} and
\emph{Optimized($\mathcal{L}(a) = 30K$)} denotes to the optimized monitors with
$1$K and $30$K limit on the size of monitor pool.
It is evident from Table~\ref{table:time} that most of the cases the benchmark
executed with the optimized monitor with less of almost equal time. That
concludes that our optimizations do not incurs any extra overhead.
Table~\ref{table:memory} represents the memory consumption data in similar way.
The memory consumption of optimized aspects are always less than the original
aspects generated by \javamop\ as the former one spawns significant lesser number
of monitors(see data in Table~\ref{table:errorreporting1}).


\subsection{Bounded Execution Time}
\label{sec:evaluation:bounded}

% \note{Add stuff about\\
% Q2. Does our approach bound worst case execution time for all monitoring 
% operations?
% }
Here we address \textbf{RQ3} \ie bound on worst case execution time. We executed
\bloat benchmarks with both \javamop generated aspects and our optimized aspect
and tabulated the execution time corresponding to each events in
Table~\ref{table:eventTime}. In all of the cases, we notice significant
reduction of event time.In \hashset\ property, we experience $99\%$ reduction of
maximum event time for \texttt{add} event.



\subsection{Effectiveness of the approach}
\label{sec:evaluation:effectiveness}

% \note{Add stuff about\\
% Q3. Does our approach effectively catch errors or does it compromise with error 
% reporting?
% }
Table~\ref{table:errorreporting1} addresses \textbf{RQ4}, \ie effectiveness of
our optimized monitoring approach. The above mentioned table provides a
comparative data of number of reported errors($\mathcal{N}(E)$) and number of
monitors allocated ($\mathcal{N}(M)$) in three scenarios : \textbf{(a)}
\emph{Original}: aspect generated by \javamop,
\textbf{(b)}\emph{Optimized($\mathcal{L}(a) = 1K$)} optimized aspect with $1$K
monitor bound on global monitor pool and \textbf{(c)}
\emph{Optimized($\mathcal{L}(a) = 30K$)} optimized aspect with $1$K monitor
bound on global monitor pool. Across all the benchmarks and properties, we
experience significant reduction of allocated monitors which resulted in lesser
memory consumption (refer~\xref{sec:evaluation:resource}). In $\mathcal{N}(E)$
column, it can be seen that our optimized monitors report lesser number of
errors. But all of these errors are not unique. Closer look to the method
context trace revealed that in case of \bloat and \avrora, all the errors
reported by the \javamop generated aspects are generated from $3$ and $9$ unique
contexts respectively. Our optimized monitor did not missed any unique error
report, rather exclude some of the ambiguous ones.

\subsection{Discussion}
\label{sec:discussion}

% \note{Add stuff about \\
% Threats to validity,\\Strengths \& Weaknesses
% }

