\documentclass{sig-alternate-05-2015}

%% =============================================================
% \def\tool{\textsc{Tool}\xspace}
% \def\papertitle{\tool: Memory-Efficient and Time-Bounded Runtime Monitoring for 
% Resource-Constrained Systems}
\def\papertitle{Memory-Efficient and Time-Bounded Runtime Monitoring for 
Resource-Constrained Systems}
\def\pdfauthors{}
\def\paperkeywords{}
%% =============================================================

\input{preamble}

%% only for the tech report
%%\makeatletter
%%\def\@copyrightspace{\relax}
%%\makeatother

\begin{document}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

% DOI
\doi{10.475/123_4}

% ISBN
\isbn{123-4567-24-567/08/06}

%Conference
\conferenceinfo{ISSTA '16}{July 17--20, 2016, Saarbrucken, Germany}

\acmPrice{\$15.00}

% %
% % --- Author Metadata here ---
% \conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
% %\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - 
% IF NEED BE.
% %\crdata{0-12345-67-8/90/01}  % Allows default copyright data 
% (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% % --- End of Author Metadata ---

\title{\Large \bf \papertitle}

% % ISSTA'16 is double blind, so removed the author block

\maketitle

\begin{abstract}
%%
\small

% % Runtime monitoring is employed in practice to ensure that a program shows 
% % expected behavior during its execution. Past decade has seen a prominent rise in 
% % the number of novel runtime monitoring frameworks and tools due to the promise 
% % shown by monitoring techniques. Many of these tools have been used effectively 
% % to verify typestate properties that are associated with legal Application 
% % Programming Interface (API) usages. In spite of their effectiveness, the tools 
% % have been occasionally found to incur significant runtime overheads, which could 
% % be even larger than the program's own execution time, particularly when the 
% % properties are associated with multiple objects. Moreover, the overheads have 
% % also been found to be extremely variable even when handling the events of the 
% % same kind. Such undesirable overheads may restrict the application of monitoring 
% % only to test environments or even worse, make it infeasible. In addition to time 
% % overheads, the monitoring tools also consume significant memory to keep 
% % monitors. 

% % Occasionally this extra memory outweighs the program's own memory requirements. 
% % All of these limitations make runtime monitoring infeasible for real-time 
% % programs that are typically executed in resource-constrained environments, where 
% % functional as well as non-functional requirements are critical.In this work, we 
% % propose a monitoring framework that investigates the trade-off between the 
% % runtime overhead and the error reporting. Our approach is motivated by the fact 
% % that there is a large redundancy among monitors in terms of their behavior which 
% % results in many monitors detecting same errors. The approach works by limiting 
% % the number of monitors based on heuristics that are related to the program 
% % execution context. In addition, the approach also limits the number of monitors 
% % that are associated with events related to a set of objects. As a result, the 
% % framework enables monitoring which consumes much less memory and provides 
% % worst-case bounds for the execution times of handling events. Moreover, our 
% % study based on some challenging typestate properties and DaCapo benchmarks 
% % indicates that our approach does not result in extra memory overhead. At the 
% % same time, it detects all the violations that an un-optimized approach detects.

Runtime monitoring is employed in practice to ensure that a program shows 
expected behavior during its execution.  However, monitoring tools, particularly 
the ones which perform inline monitoring have been occasionally found to incur 
significant and unpredictable overheads in terms of memory and time. Due to this 
reason, employing monitoring in resource-constrained environment such as 
real-time embedded system environment has been a challenge. The challenge is 
particularly big when the properties are finite state, parameterized by objects, 
and can be associated with multiple objects. In this work, we propose a novel 
monitoring approach that investigates the trade-off between the memory overhead 
and the time boundedness, and the error reporting which are key attributes of a 
real-time embedded system. Our approach is motivated by the fact that there is a 
large redundancy among monitors in terms of their behavior which results in many 
monitors detecting same errors. This redundancy can be exploited to reduce the 
number of monitors, provide worst-case time bounds to monitoring operations, and 
improve the soundness of the optimized system. Our study based on a prototype 
implementation and some challenging combinations of finite state properties and 
DaCapo benchmarks indicates that the approach can effectively control the memory 
overhead and detect the violations that an unoptimized approach can.

%%
\end{abstract}

\input{sections/ccs}
\input{sections/introduction}

\setlength\floatsep{5pt}
\setlength\textfloatsep{5pt}
\setlength\intextsep{5pt}

\input{sections/motivation}
\input{sections/approach}
%\input{sections/costmodel}
\input{sections/results}
\input{sections/related}
\input{sections/conclusion}

\clearpage

\raggedright
\small

\bibliographystyle{acm}
\bibliography{paper}

% \theendnotes

%%\justifying
%%\appendix
%%\input{sections/appendix}

\end{document}
