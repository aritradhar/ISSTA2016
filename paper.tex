\documentclass{sig-alternate-05-2015}

%% =============================================================
% \def\tool{\textsc{Tool}\xspace}
% \def\papertitle{\tool: Memory-Efficient and Time-Bounded Runtime Monitoring for 
% Resource-Constrained Systems}
\def\papertitle{Efficient Context-Aware Runtime Monitoring for Finite State Properties}
\def\pdfauthors{}
\def\paperkeywords{}
%% =============================================================

\input{preamble}

%% only for the tech report
%%\makeatletter
%%\def\@copyrightspace{\relax}
%%\makeatother

\begin{document}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

% DOI
\doi{10.475/123_4}

% ISBN
\isbn{123-4567-24-567/08/06}

%Conference
\conferenceinfo{ISSTA '16}{July 17--20, 2016, Saarbrucken, Germany}

\acmPrice{\$15.00}

% %
% % --- Author Metadata here ---
% \conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
% %\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - 
% IF NEED BE.
% %\crdata{0-12345-67-8/90/01}  % Allows default copyright data 
% (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% % --- End of Author Metadata ---

\title{\Large \bf \papertitle}

% % ISSTA'16 is double blind, so removed the author block

\maketitle

\begin{abstract}
%%
\small

% % Runtime monitoring is employed in practice to ensure that a program shows 
% % expected behavior during its execution. Past decade has seen a prominent rise in 
% % the number of novel runtime monitoring frameworks and tools due to the promise 
% % shown by monitoring techniques. Many of these tools have been used effectively 
% % to verify typestate properties that are associated with legal Application 
% % Programming Interface (API) usages. In spite of their effectiveness, the tools 
% % have been occasionally found to incur significant runtime overheads, which could 
% % be even larger than the program's own execution time, particularly when the 
% % properties are associated with multiple objects. Moreover, the overheads have 
% % also been found to be extremely variable even when handling the events of the 
% % same kind. Such undesirable overheads may restrict the application of monitoring 
% % only to test environments or even worse, make it infeasible. In addition to time 
% % overheads, the monitoring tools also consume significant memory to keep 
% % monitors. 

% % Occasionally this extra memory outweighs the program's own memory requirements. 
% % All of these limitations make runtime monitoring infeasible for real-time 
% % programs that are typically executed in resource-constrained environments, where 
% % functional as well as non-functional requirements are critical.In this work, we 
% % propose a monitoring framework that investigates the trade-off between the 
% % runtime overhead and the error reporting. Our approach is motivated by the fact 
% % that there is a large redundancy among monitors in terms of their behavior which 
% % results in many monitors detecting same errors. The approach works by limiting 
% % the number of monitors based on heuristics that are related to the program 
% % execution context. In addition, the approach also limits the number of monitors 
% % that are associated with events related to a set of objects. As a result, the 
% % framework enables monitoring which consumes much less memory and provides 
% % worst-case bounds for the execution times of handling events. Moreover, our 
% % study based on some challenging typestate properties and DaCapo benchmarks 
% % indicates that our approach does not result in extra memory overhead. At the 
% % same time, it detects all the violations that an un-optimized approach detects.

Runtime monitoring is employed in practice to ensure that a program shows 
expected behavior during its execution. However, monitoring has been 
occasionally found to incur large and unpredictable overheads in terms of memory 
and time, which makes its application challenging in resource-constrained 
environments. Past research has shown that this challenge is particularly big 
when the properties the programs are monitored for are finite state, 
parameterized, and associated with objects that are created in large numbers. In 
this work, we propose a monitoring approach that investigates various 
trade-offs associated with the overheads of monitoring, the execution times of 
monitoring operations, and the error reporting. Our approach is motivated by two key observations.
First, there is a prominent behavioral redundancy among monitors resulting in more 
than one monitors detecting same errors. Second, the events on the same or related objects are often
temporally separated from the rest. We leverage these 
observations to reduce the number of monitors, and provide compact worst-case 
time bounds to monitoring operations, without compromising much with the 
soundness of the optimized monitoring system. As a side-effect the overall time overhead also decreases.
Evaluation of the prototype 
implementation of our approach using challenging combinations of finite state properties and 
DaCapo benchmarks indicates that the approach can effectively control the 
overheads and worst-case execution times.

%%
\end{abstract}

% \input{sections/ccs}
\input{sections/introduction}

\setlength\floatsep{5pt}
\setlength\textfloatsep{5pt}
\setlength\intextsep{5pt}

\input{sections/motivation}
\input{sections/definition}
\input{sections/approach}
%\input{sections/costmodel}
\input{sections/implementation}
\input{sections/results}
\input{sections/discussion}
\input{sections/related}
\input{sections/conclusion}

\clearpage

\raggedright
\small

\bibliographystyle{acm}
\bibliography{paper}

% \theendnotes

%%\justifying
%%\appendix
%%\input{sections/appendix}

\end{document}
